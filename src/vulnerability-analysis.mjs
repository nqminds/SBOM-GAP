import { cleanCpe } from "./get-syft-cpes.mjs";
import { fetchCVEsForCPE } from "./list-vulnerabilities.mjs";
import { getCweInfo } from "./get-CWEs-info.mjs";
import { classifyCwe } from "./classify_cwe.mjs";
import { fileURLToPath } from "url";
import fs from "fs";
import path from "node:path";
import { dirname } from "path";
import {
  initialiseDatabase,
  insertOrUpdateCPEData,
  getCPEData,
} from "./database.mjs";
import {
  initialiseCveDatabase,
  getCVEData,
  insertOrUpdateCVEData,
} from "./cve_database.mjs";
import { makeClassificationRequest } from "./classify_cve.mjs";
import { readOrParseSbom } from "./utils.mjs";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const databaseDir = path.join(__dirname, "../data");
const databasePath = path.join(databaseDir, "cached_cpes.db");
const cveDatabasePath = path.join(databaseDir, "cached_cves.db");

// Check if the directory exists, if not, create it
if (!fs.existsSync(databaseDir)) {
  fs.mkdirSync(databaseDir, { recursive: true });
}

/**
 * Feeds the app with sbom data
 *
 * @param {string|object} sbomInput - Path to the SBOM JSON file or json data
 * @param {JSON} apiKeys - Nist/OpenAi API keys
 * @returns {object} - sbom data
 */
export async function extractDetails(sbomInput, apiKeys) {
  let sbomJson = await readOrParseSbom(sbomInput, __dirname);

  await initialiseDatabase(databasePath);
  await initialiseCveDatabase(cveDatabasePath);

  // Map components to an array of promises
  const resultsPromises = sbomJson.components.map(async (component) => {
    const cpe = await cleanCpe(component.cpe);

    // TODO: Refactor cleanCpe() to handle more edge cases such as: "cpe:/h:ui:usw-flex:-"
    if (!cpe.startsWith("cpe:2.3:a:")) {
      return null; // Skip this component
    }

    const name = component.name;
    const version = component.version;
    const licenses = component.licenses
      ? component.licenses.map((lic) => lic.license.name)
      : [];

    let cves = [];
    let fetchedCves;

    // Search the database first for the cpe
    const cpeData = await getCPEData(cpe, databasePath);

    if (cpeData) {
      fetchedCves = JSON.parse(cpeData.cves);
    } else if (component.cpe.trim() !== "") {
      fetchedCves = await fetchCVEsForCPE(cpe, apiKeys.nist);
      // Insert or update the cashed_cpes.db
      if (fetchedCves && Array.isArray(fetchedCves)) {
        // Insert or update the fetched data into the database
        await insertOrUpdateCPEData(
          cpe,
          name,
          version,
          licenses,
          JSON.stringify(fetchedCves),
          databasePath
        );
      }
    } else {
      fetchedCves = [];
    }

    if (fetchedCves && Array.isArray(fetchedCves)) {
      // Filter out null values
      cves = fetchedCves.filter(Boolean);
      // Add CWE info
      cves = await Promise.all(
        cves.map(async (cve) => {
          const cveData = await getCVEData(cve.id, cveDatabasePath);
          let classification = null;
          const { weakness } = cve;
          if (weakness && Array.isArray(weakness)) {
            const cwePromises = weakness.map(async (cweId) => {
              try {
                const cweInfos = await getCweInfo(cweId);
                let CweName = cweId;
                let memoryCwe = false;
                let cweType = null;
                // Save cve info if none present
                if (!cveData && apiKeys.openai) {
                  // Check if cweInfos is defined and not empty
                  if (
                    cweInfos &&
                    Array.isArray(cweInfos) &&
                    cweInfos.length > 0
                  ) {
                    const firstCweInfo = Array.isArray(cweInfos)
                      ? cweInfos[0]
                      : cweInfos;
                    CweName = firstCweInfo.Name;
                    cweType = await classifyCwe(cweId);
                  }
                  const cwe = CweName;
                  if (cwe === "NVD-CWE-noinfo" || cweType === null) {
                    classification = await makeClassificationRequest(
                      cve.description,
                      apiKeys.openai
                    );
                    cweType = classification;
                    await insertOrUpdateCVEData(
                      cve.id,
                      cve.description,
                      classification,
                      cveDatabasePath
                    );
                  }
                  // Retrieve classification from cve db
                } else {
                  if (cveData) {
                    cweType = cveData.classification;
                  } else {
                    cweType = await classifyCwe(cweId);
                  }
                }
                memoryCwe = cweType !== "not-memory-related";
                return {
                  name: CweName,
                  memoryCwe: memoryCwe,
                };
              } catch (error) {
                // TODO: decide on how we handle error
                throw new Error(`Error processing CWE ${cweId}: ${error}`);
              }
            });

            const cwes = await Promise.all(cwePromises);
            return {
              ...cve,
              cwes,
            };
          }
          return cve;
        })
      );
    }
    return cves
      ? {
          name,
          version,
          licenses,
          cves: cves.filter(Boolean),
        }
      : null;
  });

  // Await all promises in parallel and return the results
  const results = (await Promise.all(resultsPromises)).filter(Boolean);
  return results;
}
